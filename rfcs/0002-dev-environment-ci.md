# RFC 0002: Development Environment & CI

- **Status:** Accepted
- **Author(s):** @ap-1 
- **Created:** 2026-02-09  
- **Updated:** 2026-02-10

## Overview

This RFC defines the development environment setup and CI/CD strategy for Terrier. It covers local development tooling (devenv, direnv, process-compose), required services for development, Nix installation requirements, and the CI pipeline using Garnix on GitHub with container publishing to GitHub Container Registry (ghcr.io).

## Motivation

A well-defined development environment is critical for:

- Reducing onboarding friction for new contributors
- Ensuring consistency across team members' local setups
- Matching production dependencies and configurations
- Lowering the barrier to contributing to ScottyLabs' broader Nix infrastructure
- Building CI/CD muscle for our NixOS deployment infrastructure

The choice of Nix-based tooling also serves a pedagogical purpose: since ScottyLabs deploys on NixOS VMs and Terrier itself will be deployed via Nix, having contributors comfortable with Nix reduces friction when bumping package versions (e.g., Keycloak in nixpkgs) or contributing to other DevOps repositories.

## Goals

- Provide a reproducible development environment across macOS, Linux, and WSL
- Minimize time from git clone to running application
- Run all backend services locally without manual setup
- Share Nix configuration between development and CI
- Fast CI builds with effective caching
- Automatic container image builds and publishing
- Make Nix adoption reversible (provide clear uninstall path)

## Non-Goals

- Supporting Windows native development (WSL only)
- Building a custom CI platform
- Supporting multiple development environment options, like Docker Compose or Dev Containers

## Detailed Design

### Development Environment

**Core tooling:**

- **devenv**: Declarative dev environment manager
- **direnv**: Automatic environment activation on cd
- **process-compose**: Service orchestration for local development

We use a standalone `devenv.nix` file rather than integrating devenv into `flake.nix` via the flake module. The devenv documentation explicitly recommends this approach: when integrated into flakes, devenv provides only a "stripped down version" with reduced features and performance limitations. The hybrid approach gives us:

- Full devenv feature set (not just `up` and `shell` subcommands)
- Version-locked devenv per project (via flake.nix providing the devenv binary)
- Best performance for daily development

**Directory structure:**

```
/
├── .devenv/                # devenv state (gitignored)
├── .direnv/                # direnv state (gitignored)
├── .envrc                  # direnv: auto-loads devenv
├── .pre-commit-config.yaml # Autogenerated pre-commit hooks configuration (gitignored)
├── flake.lock              # Locked dependencies
├── flake.nix               # Nix flake: packages, devenv binary
└── devenv.nix              # Development environment config
```

**Services in development:**

All services run via process-compose defined in devenv.nix:

1. **PostgreSQL** (primary database)
   - Initialized with development schema
   - Accessible via Unix socket (no TCP in development)
   - Database migrations run automatically via sea-orm in main.rs at startup

2. **Valkey** (Open-source Redis fork - sessions, cache, pub/sub)
   - Accessible via Unix socket (no TCP in development)

3. **MinIO** (S3-compatible object storage)
   - Local S3 for file uploads
   - MinIO Console enabled for browsing buckets (port 9001)

**Non-local services:**

For auth, the application will point to the ScottyLabs Keycloak instance, using the terrier-dev client in the terrier realm. We won't use a local Keycloak instance for development since it's heavy and slow to start up. Development mode will log outgoing emails to stdout rather than sending them. We won't use a mock SMTP server locally for the same reason.

### Nix Installation Requirements

We encourage contributors to use the [Determinate Systems Nix installer](https://github.com/DeterminateSystems/nix-installer) rather than the official Nix installer. Reasons:

1. Provides a working uninstaller (official Nix has problematic uninstall)
2. Better defaults for Flakes and nix-command

This keeps the barrier to entry low - contributors know they can fully remove Nix if they decide it's not for them.

**Setup guides:**

We'll provide comprehensive setup documentation for:

- macOS (Apple Silicon)
- Linux (NixOS)
- Windows via WSL2 (Ubuntu)

Each guide covers:

1. Installing Determinate Systems Nix
2. Installing direnv
3. Cloning repo and first-time setup (running `direnv allow`)
4. Running the development environment
5. Uninstalling Nix if needed

### CI Strategy

**Platform:**

We use Garnix for CI rather than GitHub Actions or Forgejo Actions. Garnix has the following advantages:

- 2-10x faster than GitHub Actions
- Free tier: 1,500 CI minutes/month
- Zero-configuration Nix caching (content-addressed, globally deduplicated)
- No special cache setup required
- Cache shared between all garnix users (if someone built a derivation, you get it)
- Native GitHub integration (PR status checks, branch builds)

The repository is hosted on GitHub as the primary, with an automatic mirror to Codeberg. This gives us full Garnix integration including PR builds and status checks, which wouldn't be possible with a Codeberg-primary setup since Garnix only supports GitHub. The Codeberg mirror ensures the project remains accessible on a FOSS-friendly platform.

**Workflow:**

1. Code pushed to GitHub (primary)
2. GitHub webhook triggers Garnix / Codeberg mirroring
3. Garnix builds on Garnix's servers
4. Results cached at cache.garnix.io
5. Status posted to GitHub PR / commit
6. On push to main, Garnix Action pushes container image to ghcr.io

Garnix automatically evaluates the flake and builds:

- All packages (backend, frontend, containers)
- All checks (tests, lints, formatting)
- All devShells (to verify dev environment works)

We can customize what builds via optional `garnix.yaml` config file.

**Garnix cache configuration:**

The garnix cache is configured in `flake.nix` using the `nixConfig` attribute, which prompts users to accept the cache on first use:

```nix
{
  nixConfig = {
    extra-substituters = [ "https://cache.garnix.io" ];
    extra-trusted-public-keys = [ "cache.garnix.io:CTFPyKSLcx5RMJKfLo5EEPUObbA78b0YQ2DTCJXqr9g=" ];
  };
  
  inputs = {
    nixpkgs.url = "github:cachix/devenv-nixpkgs/rolling";
    devenv.url = "github:cachix/devenv";
  };
  
  outputs = { ... };
}
```

When developers first run `nix develop` or `devenv shell`, they'll be prompted to trust the cache. Once accepted, anything built in CI is instantly available locally with no rebuilding.

NixOS users can optionally add the cache system-wide in their configuration:

```nix
nix.settings = {
  extra-substituters = [ "https://cache.garnix.io" ];
  extra-trusted-public-keys = [ "cache.garnix.io:CTFPyKSLcx5RMJKfLo5EEPUObbA78b0YQ2DTCJXqr9g=" ];
};
```

### Container Building and Publishing

**Container creation:**

We use `nix2container` rather than `dockerTools.buildImage` for significantly faster rebuild/push cycles. The container is defined in flake.nix outputs:

```nix
packages.x86_64-linux.container = 
  nix2container.buildImage {
    name = "terrier";
    config = {
      entrypoint = ["${self.packages.x86_64-linux.backend}/bin/terrier"];
    };
    layers = [
      (nix2container.buildLayer { 
        deps = [ /* runtime dependencies */ ]; 
      })
    ];
  };
```

**Note:** There is only one container. The backend serves the frontend in production (as opposed to development, which uses the Vite dev server + HMR). The container includes both the Rust backend binary and the built frontend assets.

Additional benefits of nix2container:
- Doesn't write tarballs to /nix/store
- Skips already-pushed layers and deduplicates them

We publish containers to GitHub Container Registry at `ghcr.io/scottylabs/terrier`. Images are pulled in docker-compose.yml as:

```yaml
services:
  terrier:
    image: ghcr.io/scottylabs/terrier:latest
```

**Publishing workflow:**

Garnix Actions push container images to ghcr.io after successful builds on the main branch. This requires configuring Garnix with:

- GitHub Container Registry credentials (GitHub PAT or `GITHUB_TOKEN` with `packages:write` scope)
- A Garnix Action that runs `skopeo copy` or equivalent to push the nix2container image to ghcr.io

### Git Hooks

Pre-commit hooks managed via devenv's pre-commit integration. Hooks are defined in devenv.nix:

- `nixpkgs-fmt` - Nix code formatting
- `clippy` - Rust linting
- `rustfmt` - Rust code formatting
- `biome` - Frontend linting and formatting (TypeScript, Svelte, JSON, etc.)

**Note on frontend tooling:** We currently use Biome for frontend linting and formatting. We may switch to oxc (oxlint/oxfmt) in the future once it has better Svelte support.

Hooks are automatically installed when entering the dev environment. The same checks run in CI, ensuring consistency.

## Alternatives Considered

### Development Environment Alternatives

**Docker Compose for development:**

Many projects use Docker Compose for local development. We rejected this because:

- Doesn't help contributors learn Nix (our deployment target)
- Separate configuration from production (more to maintain)
- Slower startup than process-compose
- Doesn't integrate with our NixOS infrastructure

We're making a pedagogical choice: by having contributors use Nix for development, they're better equipped to contribute to ScottyLabs' broader infrastructure and understand Terrier's deployment.

**devenv integrated into flake.nix:**

We could use devenv's flake module to integrate everything into flake.nix. We chose a separate devenv.nix because:

- devenv documentation explicitly recommends standalone for best experience
- Flake integration provides "stripped down version" with limited features
- Performance is worse when integrated
- Complexity of flake.nix would increase

**Multiple environment options:**

We could support multiple dev environment setups (Docker, Nix, manual). We chose to standardize on Nix because:

- ScottyLabs has a fleet of NixOS VMs, so contributors will encounter Nix anyway
- Multiple options means multiple things to maintain
- Nix provides the best match to production
- Better to have one well-documented path than several mediocre ones

### CI Alternatives

**GitHub Actions:**

The obvious choice given our GitHub mirror. We chose Garnix instead because:

- Garnix is 2-10x faster (benchmarked)
- Zero-configuration caching (no Cachix setup, no magic-nix-cache config)
- Global cache means maximum reuse across all garnix users
- Still posts status to GitHub

**Forgejo Actions only, with self-hosted cache:**

We could run everything on our self-hosted Forgejo runners and self-hosted cache. We chose Garnix + its cache instead because:

- We don't have to deploy Attic or Harmonia
- Garnix cache is globally shared 
- Faster builds than setting up our own cache

**ghcr.io vs. Codeberg Registry vs. Docker Hub:**

We chose GitHub Container Registry (ghcr.io) because:

- Integrates naturally with our GitHub-primary setup
- Generous storage for public packages (no exception requests needed)
- Garnix Actions can push directly after builds

Codeberg registry was considered but adds complexity (cross-platform credential management) and storage quota constraints. Docker Hub has rate limits and requires a separate account.

## Open Questions

1. **Valkey GUI:** Do we include Redis Commander in process-compose, or is valkey-cli sufficient for development? Trade-off is convenience vs. lighter dev environment.

2. **Container tagging strategy:** Do we tag with git commit SHA, semantic version, both? How do we handle `latest` tag?

3. **GithubCodebergMirror hosting:** There exists a mirror bot that can mirror GitHub PRs, issues, etc. to Codeberg in addition to the git repository. It could run on our NixOS VMs, but it requires writing a flake.nix file to define the bot's configuration and dependencies.

## Implementation Phases

### Development Environment Setup

- Create devenv.nix with all services (Postgres, Valkey, MinIO)
- Configure process-compose for service orchestration
- Add .envrc for direnv integration
- Test on macOS, Linux, WSL
- Write setup guides for each platform
- Configure git hooks via pre-commit (nixpkgs-fmt, clippy, rustfmt, biome)

### CI Configuration

- Install Garnix GitHub App on scottylabs/terrier
- Add garnix.yaml if we need custom build configuration
- Verify CI builds packages, checks, devShells
- Add garnix cache to flake.nix nixConfig
- Test cache hit rates and build times
- Set up GithubCodebergMirror for Codeberg sync

### Container Publishing

- Define container using nix2container in flake.nix
- Configure Garnix Action to push to ghcr.io
- Test end-to-end: code push -> garnix -> ghcr.io
- Update docker-compose.yml to pull from ghcr.io
- Document container publishing workflow
