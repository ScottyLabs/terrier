# RFC 0002: Development Environment & CI

- **Status:** Accepted
- **Author(s):** @ap-1
- **Created:** 2026-02-09
- **Updated:** 2026-02-10

## Overview

This RFC defines the development environment setup and CI/CD strategy for Terrier. It covers local development tooling (devenv, direnv, process-compose), required services for development, Nix installation requirements, and the CI pipeline using self-hosted Forgejo runners with container publishing to Codeberg's registry.

## Motivation

A well-defined development environment is critical for:

- Reducing onboarding friction for new contributors
- Ensuring consistency across team members' local setups
- Matching production dependencies and configurations
- Lowering the barrier to contributing to ScottyLabs' broader Nix infrastructure
- Building CI/CD muscle for our NixOS deployment infrastructure

The choice of Nix-based tooling also serves a pedagogical purpose: since ScottyLabs deploys on NixOS VMs and Terrier itself will be deployed via Nix, having contributors comfortable with Nix reduces friction when bumping package versions (e.g., Keycloak in nixpkgs) or contributing to other DevOps repositories.

## Goals

- Provide a reproducible development environment across macOS, Linux, and WSL
- Minimize time from git clone to running application
- Run all backend services locally without manual setup
- Share Nix configuration between development and CI
- Fast CI builds with effective caching
- Automatic container image builds and publishing
- Make Nix adoption reversible (provide clear uninstall path)

## Non-Goals

- Supporting Windows native development (WSL only)
- Building a custom CI platform
- Supporting multiple development environment options, like Docker Compose or Dev Containers

## Detailed Design

### Development Environment

**Core tooling:**

- **devenv**: Declarative dev environment manager
- **direnv**: Automatic environment activation on cd
- **process-compose**: Service orchestration for local development

We use a standalone `devenv.nix` file rather than integrating devenv into `flake.nix` via the flake module. The devenv documentation explicitly recommends this approach: when integrated into flakes, devenv provides only a "stripped down version" with reduced features and performance limitations. The hybrid approach gives us:

- Full devenv feature set (not just `up` and `shell` subcommands)
- Version-locked devenv per project (via flake.nix providing the devenv binary)
- Best performance for daily development

**Directory structure:**

```
/
├── .devenv/                # devenv state (gitignored)
├── .direnv/                # direnv state (gitignored)
├── .envrc                  # direnv: auto-loads devenv
├── .pre-commit-config.yaml # Autogenerated pre-commit hooks configuration (gitignored)
├── flake.lock              # Locked dependencies
├── flake.nix               # Nix flake: packages, devenv binary
└── devenv.nix              # Development environment config
```

**Services in development:**

All services run via process-compose defined in devenv.nix:

1. **PostgreSQL** (primary database)

   - Initialized with development schema
   - Accessible via Unix socket (no TCP in development)
   - Database migrations run automatically via sea-orm in main.rs at startup

1. **Valkey** (Open-source Redis fork - sessions, cache, pub/sub)

   - Accessible via Unix socket (no TCP in development)

1. **MinIO** (S3-compatible object storage)

   - Local S3 for file uploads
   - MinIO Console enabled for browsing buckets (port 9001)

**Non-local services:**

For auth, the application will point to the ScottyLabs Keycloak instance, using the terrier-dev client in the terrier realm. We won't use a local Keycloak instance for development since it's heavy and slow to start up. Development mode will log outgoing emails to stdout rather than sending them. We won't use a mock SMTP server locally for the same reason.

### Nix Installation Requirements

We encourage contributors to use the [Determinate Systems Nix installer](https://github.com/DeterminateSystems/nix-installer) rather than the official Nix installer. Reasons:

1. Provides a working uninstaller (official Nix has problematic uninstall)
1. Better defaults for Flakes and nix-command

This keeps the barrier to entry low - contributors know they can fully remove Nix if they decide it's not for them.

**Setup guides:**

We'll provide comprehensive setup documentation for:

- macOS (Apple Silicon)
- Linux (NixOS)
- Windows via WSL2 (Ubuntu)

Each guide covers:

1. Installing Determinate Systems Nix
1. Installing direnv
1. Cloning repo and first-time setup (running `direnv allow`)
1. Running the development environment
1. Uninstalling Nix if needed

### CI Strategy

**Platform:**

We use self-hosted Forgejo runners on ScottyLabs' NixOS infrastructure with Cachix for binary caching. This gives us:

- Unlimited CI minutes (self-hosted)
- Nix-native builds on our own hardware
- Binary cache shared between CI and local development via Cachix
- Full control over runner configuration and capacity
- No dependency on third-party CI services

**Workflow:**

1. Code pushed to Codeberg (primary)
1. Forgejo Actions trigger on the self-hosted runner
1. Runner builds all flake outputs using Nix
1. Built derivations pushed to Cachix
1. Status posted to Codeberg PR / commit
1. On push to main, container image pushed to Codeberg registry

The CI workflow evaluates the flake and builds:

- All packages (backend, frontend, containers)
- All checks (lints, formatting)
- All devShells (to verify dev environment works)

**Cachix configuration:**

Cachix provides binary caching shared between CI and local development. The cache is configured in devenv.nix:

```nix
{
  cachix.pull = [ "devenv" "scottylabs-terrier" ];
  cachix.push = "scottylabs-terrier";
}
```

When developers first enter the devenv shell, built derivations from CI are available immediately via the cache. The CI runner pushes new derivations after each build.

Developers can optionally add the cache system-wide in their configuration:

```nix
nix.settings = {
  extra-substituters = [ "https://scottylabs-terrier.cachix.org" ];
  extra-trusted-public-keys = [ /* key from cachix */ ];
};
```

### Container Building and Publishing

**Container creation:**

We use `nix2container` rather than `dockerTools.buildImage` for significantly faster rebuild/push cycles. The container is defined in flake.nix outputs:

```nix
packages.x86_64-linux.container = 
  nix2container.buildImage {
    name = "terrier";
    config = {
      entrypoint = ["${self.packages.x86_64-linux.backend}/bin/terrier"];
    };
    layers = [
      (nix2container.buildLayer { 
        deps = [ /* runtime dependencies */ ]; 
      })
    ];
  };
```

**Note:** There is only one container. The backend serves the frontend in production (as opposed to development, which uses the Vite dev server + HMR). The container includes both the Rust backend binary and the built frontend assets.

Additional benefits of nix2container:

- Doesn't write tarballs to /nix/store
- Skips already-pushed layers and deduplicates them

**Registry:**

We publish containers to Codeberg's container registry at `codeberg.org/scottylabs/terrier`. This keeps artifacts aligned with the primary repository on Codeberg.

Images are pulled in docker-compose.yml as:

```yaml
services:
  terrier:
    image: codeberg.org/scottylabs/terrier:latest
```

**Publishing workflow:**

The Forgejo Actions CI workflow pushes container images to Codeberg registry after successful builds on the main branch. This requires configuring the runner with:

- Codeberg registry credentials (PAT or service account)
- Push step using `skopeo copy` or equivalent to push the nix2container image

**Codeberg storage quotas:**

Codeberg has default storage limits (750 MiB git, 1.5 GB LFS, separate container registry limits). Container images will likely exceed defaults quickly. Codeberg's philosophy: "We will grant every project the resources it needs, provided that we can afford them... there is no quota for valid use-cases."

When we reach halfway to storage limits, we'll submit an exception request via https://codeberg.org/Codeberg-e.V./requests with:

- Project description (AGPL-3.0 hackathon platform)
- Use case (self-hostable product, distributing containers)
- Estimated needs (container images with multiple release tags)
- ScottyLabs/CMU context

Terrier fits exactly the kind of FOSS project Codeberg wants to support, so approval is expected. Otherwise, we can explore alternative hosting solutions.

### Git Hooks

Pre-commit hooks managed via devenv's pre-commit integration. Hooks are defined in devenv.nix:

- `nixpkgs-fmt` - Nix code formatting
- `clippy` - Rust linting
- `rustfmt` - Rust code formatting
- `biome` - Frontend linting and formatting (TypeScript, Svelte, JSON, etc.)

**Note on frontend tooling:** We currently use Biome for frontend linting and formatting. We may switch to oxc (oxlint/oxfmt) in the future once it has better Svelte support.

Hooks are automatically installed when entering the dev environment. The same checks run in CI, ensuring consistency.

## Alternatives Considered

### Development Environment Alternatives

**Docker Compose for development:**

Many projects use Docker Compose for local development. We rejected this because:

- Doesn't help contributors learn Nix (our deployment target)
- Separate configuration from production (more to maintain)
- Slower startup than process-compose
- Doesn't integrate with our NixOS infrastructure

We're making a pedagogical choice: by having contributors use Nix for development, they're better equipped to contribute to ScottyLabs' broader infrastructure and understand Terrier's deployment.

**devenv integrated into flake.nix:**

We could use devenv's flake module to integrate everything into flake.nix. We chose a separate devenv.nix because:

- devenv documentation explicitly recommends standalone for best experience
- Flake integration provides "stripped down version" with limited features
- Performance is worse when integrated
- Complexity of flake.nix would increase

**Multiple environment options:**

We could support multiple dev environment setups (Docker, Nix, manual). We chose to standardize on Nix because:

- ScottyLabs has a fleet of NixOS VMs, so contributors will encounter Nix anyway
- Multiple options means multiple things to maintain
- Nix provides the best match to production
- Better to have one well-documented path than several mediocre ones

### CI Alternatives

**Garnix:**

Garnix offers fast Nix CI with a global cache, but its free tier (1,500 minutes/month) proved insufficient for a Rust project with many crate dependencies. It also only supports GitHub, which would require making GitHub the primary repository.

**GitHub Actions + Magic Nix Cache:**

GitHub Actions with the Magic Nix Cache action provides free CI with Nix caching, but it requires GitHub as the primary platform. The Magic Nix Cache uses GitHub's Actions Cache API, which is not compatible with Forgejo Actions.

**Forgejo Actions only, without shared cache:**

We could skip Cachix and rely only on the runner's local Nix store. We chose to add Cachix because:

- Local developers benefit from cached CI builds
- The 5 GB free tier is sufficient for one project
- Zero operational burden compared to self-hosting Attic or Harmonia

**Codeberg Registry vs. ghcr.io vs. Docker Hub:**

We considered publishing containers to GitHub Container Registry or Docker Hub. We chose Codeberg registry because:

- Keeps artifacts with primary repository
- Philosophically consistent (don't strengthen GitHub's network effects)
- Codeberg supports FOSS projects generously

ghcr.io would be simpler (no exception request needed) but compromises our principle of keeping infrastructure on Codeberg where practical.

## Open Questions

1. **Valkey GUI:** Do we include Redis Commander in process-compose, or is valkey-cli sufficient for development? Trade-off is convenience vs. lighter dev environment.

1. **Container tagging strategy:** Do we tag with git commit SHA, semantic version, both? How do we handle `latest` tag?

## Implementation Phases

### Development Environment Setup

- Create devenv.nix with all services (Postgres, Valkey, MinIO)
- Configure process-compose for service orchestration
- Add .envrc for direnv integration
- Test on macOS, Linux, WSL
- Write setup guides for each platform
- Configure git hooks via pre-commit (nixpkgs-fmt, clippy, rustfmt, biome)

### CI Configuration

- Set up self-hosted Forgejo runner on ScottyLabs NixOS infrastructure
- Create Cachix cache (scottylabs-terrier)
- Write Forgejo Actions workflow (.forgejo/workflows/ci.yml)
- Configure Cachix push in CI and pull in devenv.nix
- Verify CI builds packages, checks, devShells
- Test cache hit rates and build times

### Container Publishing

- Define container using nix2container in flake.nix
- Configure Forgejo workflow to push to Codeberg registry
- Test end-to-end: code push -> runner -> registry
- Update docker-compose.yml to pull from Codeberg
- Document container publishing workflow
