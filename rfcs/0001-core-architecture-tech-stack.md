# RFC 0001: Core Architecture & Tech Stack

- **Status:** Accepted
- **Author(s):** @ap-1
- **Created:** 2026-02-08
- **Updated:** 2026-02-10

## Overview

This RFC establishes the core technology stack for Terrier: Rust + Axum for the backend, Svelte for the frontend, and Tauri for mobile. We'll follow 12-factor app principles to support both self-hosted and cloud deployments with high availability.

## Motivation

Terrier needs to work across very different deployment scenarios. University hackathons will want to self-host on their own infrastructure with full data control, and large hackathons need high availability during registration and judging. Student developers need to iterate quickly. And we need to distribute the platform via multiple targets to ensure as many people as possible can use it.

The stack needs to balance performance (handling hundreds to thousands of concurrent users), maintainability (for a rotating student team), and operational simplicity (easy to deploy and monitor).

## Goals

- Define backend, frontend, and mobile technologies
- Establish architectural principles for future RFCs
- Support multiple deployment environments
- Enable horizontal scaling and HA
- Fast iteration cycles for developers

## Non-Goals

This RFC covers high-level architecture. Specifics on API design, database schemas, authentication implementation, deployment configuration, and observability setup are deferred to later RFCs.

## Detailed Design

### Backend

We're using Rust with Axum. Rust's type system catches bugs at compile time, performs comparably to C/C++, and has no GC pauses (important for real-time features). The ecosystem is mature with Axum, sqlx, sea-orm, tower, and tokio all production-ready.

Axum specifically because it's built on Tower middleware (widely used), integrates well with OpenTelemetry and Sentry, has type-safe extractors that reduce boilerplate, and is actively maintained by the Tokio team.

The API will be REST endpoints for CRUD, WebSockets for real-time features, with OpenAPI 3.1 specs generated by utoipa. Frontend gets type-safe clients via openapi-typescript.

### Frontend

We're using Svelte with Vite. It's simple with minimal boilerplate, performs well by compiling to vanilla JS, and people are sick of React. Vite also gives instant HMR.

Type safety bridge works like this: Rust backend generates OpenAPI spec, openapi-typescript generates TypeScript types, openapi-fetch provides the type-safe client. This crates a single source of truth from Rust structs through to TypeScript.

### Mobile

Tauri for native mobile. It's Rust-native (reduces context switching), produces small bundles (~5MB vs Capacitor's 10-50MB), and v2 has production-ready plugins for everything we need: deep links, push notifications, QR scanning, geolocation, biometric auth, NFC.

It uses the same Svelte frontend as web and prevents the FFI hell present in Dioxus mobile where you'd write Swift/Kotlin for every platform API.

Multi-instance support works like Mastodon/Nextcloud: single "Terrier" app in app stores, users enter their instance URL on first launch, app fetches branding dynamically and applies it at runtime. We'll bundle 10-20 icon color variants using iOS setAlternateIconName and Android activity-alias.

Trade-off: app store listing and home screen show "Terrier" branding, but inside the app it's fully branded per instance.

### 12-Factor App Principles

We're following the [12-factor methodology](https://12factor.net/):

1. Single monorepo in Git
2. Explicit dependencies via Cargo.toml and package.json  
3. Config in environment variables
4. Postgres, Redis, S3 as attached resources
5. Build/release/run separation via CI/CD
6. Stateless processes with sessions in Redis
7. Self-contained HTTP server
8. Horizontal scaling via multiple instances
9. Fast startup, graceful shutdown on SIGTERM
10. Docker Compose mirrors production
11. Structured logging to stdout
12. Database migrations as separate processes

Configuration splits between environment variables (deployment-specific: DATABASE_URL, REDIS_URL, S3_ENDPOINT, SMTP credentials, OIDC config) and database (user-facing: hackathon branding, email templates, judging rubrics, feature toggles). This keeps secrets out of the database and allows the same binary to work across dev/staging/prod.

### Stateless Design for HA

Multiple app instances run behind a load balancer with no shared in-memory state. Sessions live in Redis with TTL, not in memory. WebSocket state uses Redis pub/sub for cross-instance communication. File uploads go to S3-compatible storage and background jobs use a queue system. All of these will be discussed in future RFCs.

### Architecture Overview

The basic architecture is multiple Axum server instances behind a load balancer (nginx, AWS ALB, etc), all connecting to shared Postgres (with replication), Redis/Valkey (for sessions, pub/sub, and cache), and S3-compatible object storage (MinIO, S3, R2, etc). Web frontend is Svelte + Vite, mobile is Tauri wrapping the same Svelte code.

REST API for CRUD operations, WebSockets for real-time updates. We considered Server-Sent Events but need bidirectional communication for judging.

Type safety flows from Rust backend through OpenAPI spec generation to TypeScript types. Refactoring a Rust struct automatically updates TypeScript types. You won't be able to call the API with the wrong types, and IDE autocomplete works across the boundary.

## Alternatives Considered

### Backend

- **Go + Gin/Echo** - Simpler than Rust with faster compile times and strong concurrency primitives. But less type safety (no ADTs, nil pointers), GC pauses that could affect real-time features, and weaker async ecosystem.
- **Elixir + Phoenix** - Excellent for real-time with LiveView and OTP supervision. But adds another language to the stack, smaller enterprise ecosystem, and less team familiarity.
- **TypeScript + Node.js** - Single language across the stack with huge ecosystem. But runtime type errors, performance limitations for CPU-intensive work, and less suitable for long-running processes.

Rust's type safety and performance justify the learning curve for a production platform.

### Frontend

- **React** - Off the table since it's unpopular with the team. Also, it has too much boilerplate and ecosystem fatigue.
- **Vue** - Similar simplicity to Svelte with large ecosystem. But more ceremony and the Composition API vs Options API split is annoying.
- **Solid.js** - Excellent performance and React-like syntax without virtual DOM. But smaller ecosystem and less mature tooling.

Svelte has the best balance of simplicity, performance, and maturity.

### Mobile

- **Capacitor** - Production-ready with rich plugins. But JavaScript bridge layer, larger bundles, and we prefer Rust-native.
- **Dioxus Mobile** - Rust-native UI with unified language. But no plugin system, requires manual Swift/Kotlin FFI for every native API. Massive engineering effort.
- **React Native** - Mature ecosystem. But not aligned with Rust backend, larger bundles, bridge performance overhead.
- **Flutter** - Great performance and widget library. But Dart adds another language and separate codebase from web.
- **PWA** - No app stores needed, single codebase. But limited native APIs (especially iOS), no push on iOS, worse offline. Not production-ready for hackathon needs.

Tauri v2 is stable, Rust-native, small bundles, and has all the native APIs we need.

### HTTP Protocol

- **HTTP/3** - Better connection performance with 0-RTT and no head-of-line blocking. But Rust crates are not yet production-ready and the benefit is marginal since WebSockets handle reconnection well anyway.

We'll use HTTP/2.

### API Style

- **gRPC** - 20-30% better latency and faster parsing with Protocol Buffers. But incompatible with OpenAPI (.proto files instead), loses Swagger UI, and the performance gains are negligible for requests over the internet vs internal microservices.
- **GraphQL** - Flexible querying reduces over-fetching with strong typing. But more complexity than needed, caching is harder than REST, N+1 query problems.

REST + OpenAPI is the right balance of simplicity, tooling, and team accessibility.

## Open Questions

- Is Subsecond's experimental status (requires --hotpatch flag) acceptable for a production-targeting student project? We can fall back to cargo watch (now bacon) if it's unstable.
- Docker Compose vs devenv vs local setup for development?
- How many icon color variants should we bundle for mobile? Which colors?
- Do we need /api/v1/ versioning from day one? Do we need API versioning in the first place?

## Implementation Phases

**Initial Setup**

- Create Rust workspace with Axum
- Create Svelte project with Vite
- Verify OpenAPI spec generation works
- Basic request/response flow working

**Developer Tooling**

- Get Subsecond hot-reload working
- Set up local development environment
- Document the development workflow

**Mobile Proof of Concept**

- Create Tauri mobile project
- Verify it can run the Svelte frontend
- Test on actual devices
